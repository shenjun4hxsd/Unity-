##物理系统（2/3）

###Rigidbody

**概念**

    通过物理模拟控制一个物体的位置。
    添加Rigidbody组件到一个对象，这就置于了Unity的物理引擎下使其运动。即使没有添加任何代码，刚体对象也将在重力的影响下下落，如果带有碰撞器的对象与之碰撞，并将做出反应。

    从脚本添加力到刚体对象上，以真实的物理方法来控制它。例如，轿车的行为可以给轮胎施加力，物理引擎处理运动的其他方面，因此，会有更真实的加速度和正确的碰撞反应。

    在脚本，FixedUpdate函数中被推荐放置应用力以及修改刚体设置（相对于Update，应用其他大部分更新任务）。物理更新的时间间隔与update是不一致的，在每个物理更新之前，FixedUpdate被立即调用，所以所作的任何更改会直接处理。

    当刚体运行开始常见的问题是，游戏物理引擎看上去运行像“慢镜头”。这实际上由于你模型的大小，默认重力设置假定为每世界单位1米距离。对非物理游戏，你的模型缩放100单位也没有多大差别，但当使用物理引擎，它们将被视为非常大的对象。如果应该是小对象使用较大的缩放，它们将出现下落很慢，物理引擎认为它是非常大的对象，下落较大的距离。考虑到这一点，请确保你的对象接近真实生活的大小（例如，轿车应该是大约4单位=4米）。



>对于Unity引擎来说，所有力学的处理都应该放在FixedUpdate进行。

>注意：不要更改Time属性中的固定时间，如果更改了可能会造成物理引擎不同步问题

###面板属性：
```
    Mass
        物体质量(单位“千克”)
        注意：质量不能为0，而且质量尽量大于10，保持在[0.1 -- 10]范围内;
    Drag
        平移方向的阻力
        他不代表物体和物体的接触阻力，他只表达空气对物体的阻力
    Angluar Drag
        选择的空气角阻力
    User Gravity
        是否使用重力
        这个选项表示你是否使用世界正方向上的下压力
    Is Kinematic
        是否遵循牛顿物理学定律
        注意：如果为true，他会让刚体失去，力学、碰撞、万有引力；
    Interpolate
        物理运动差值
        提供在物理运动上时候的逐帧渲染效果，如果使用该选择但是你的帧渲染不够快会导致物体的轻微抖动现象，所以我们建议这个属性尽量应用在主角身上而不是NPC身上
    Collision Detection
        碰撞检测模式
            Discrete
                非连续性碰撞，效率高但是精度很低，适用于慢动作物体
            Continuous
                连续碰撞检测
                效率适中，精度有所提高，适用于汽车这样高速但是体积庞大的物体运动
            ContinuousDynamic
                连续动态碰撞
                精度最高，但是效率最差，适用于体积较小碰撞紧密的运动物体，例如：炮弹
    Constraints
        冻结平移运动和选择运动
        他可以讲物体的三个轴上的平移力忽略掉，也可以忽略三个轴上的旋转力。他和User Gravity 不一样，他是让这些轴永远不发生任何力的效果

```


###API

|变量|说明|
|:--|:--|
|angularDrag|刚体的角阻力。|
|angularVelocity|刚体的角速度向量。|
|centerOfMass|相对于变换原点的质心。|
|collisionDetectionMode|刚体的碰撞检测模式。|
|constraints|控制该刚体模拟允许的自由度。|
|detectCollisions|碰撞检测应否启用？（默认总是启用的）|
|drag|刚体的阻力。|
|freezeRotation|控制物理是否改变物体的旋转。|
|inertiaTensor|相对于重心的质量的惯性张量对角线。|
|inertiaTensorRotation|惯性张量的旋转。|
|interpolation|插值允许你以固定的帧率平滑物理运行效果。|
|isKinematic|控制物理是否够影响这个刚体。|
|mass|刚体的质量。|
|maxAngularVelocity|刚体的最大角速度，（默认7）范围{0, 无穷大}|
|maxDepenetrationVelocity|当非穿透状态时，刚体的最大速度。|
|**position**|该刚体的位置。|
|**rotation**|刚体的旋转角度。|
|sleepThreshold|哪个对象开始进入休眠状态，质量归一化的能量阈值。|
|solverIterationCount|允许你覆盖每个刚体的求解迭代次数。|
|useConeFriction|用于该刚体的锥形摩擦力。|
|**useGravity**|控制重力是否影响整个刚体。|
|**velocity**|刚体的速度向量。|
|worldCenterOfMass|在世界坐标空间的刚体的质量中心。（只读）|

|公共方法|说明|
|:--|:--|
|AddExplosionForce|应用一个力到刚体来模拟爆炸效果。|
|**AddForce**|添加到刚体的力。|
|AddForceAtPosition|在position位置应用force力。作为结果这个将在这个物体上应用一个扭矩和力。|
|AddRelativeForce|添加力到刚体。相对于它的系统坐标。|
|AddRelativeTorque|相对于它的局部坐标系统添加扭矩到刚体。|
|AddTorque|添加扭矩到刚体。|
|ClosestPointOnBounds|指定位置到该刚体附加的碰撞器的最近点。|
|GetPointVelocity|刚体在世界坐标空间，worldPoint点的速度。|
|GetRelativePointVelocity|相对于刚体在relativePoint点的速度。|
|IsSleeping|刚体在休眠么？|
|**MovePosition**|移动刚体到新位置。|
|**MoveRotation**|旋转刚体到新角度。|
|ResetCenterOfMass|重置刚体的质心。|
|ResetInertiaTensor|重置惯性张量值和旋转。|
|SetDensity|设置基于附加的碰撞器假设一个固定的密度质量。|
|Sleep|强制刚体休眠。|
|SweepTest|如果一个刚体碰到任何东西触发测试。|
|SweepTestAll|就像Rigidbody.SweepTest，当返回的是所有碰撞信息。|
|WakeUp|强制一个刚体唤醒。|




🔚
