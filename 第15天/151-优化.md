##优化

####1、添加雾效

####2、烘焙光照贴图
    静态物体的处理
    Light Probes

**1.single lightmaps**

该类型是最简单的一种lightmmaping方式，对性能及空间的消耗相对较小，可以很好的表现大多数静态场景的光影效果，但是在作用在游戏对象时不会考虑到使用bump/specshader类型的材质，这是应对该类型的材质需要在实时光源照射下才会起作用，另外，所烘焙出来的光照贴图不作用于场景中动态物体，比如动态物体在阴影时，不会把这个动态物体变的暗些，当然添加light probes是解决这个问题的一种方法,同时会产生双重阴影，single lightmaps烘焙时考虑到是bump/specshader类型的材质，但也是把静态的凹凸效果烘焙在lightmap中，注意：只有在resolution值足够大时，或者说使用lightmap尺寸足够大时，才能表现这些凹凸细节，这样会导致需要的用到的更多张lightmap，因此他不能作为一种通用方案，只能用在少时物体上，如果想在使用光照贴图的同时为静态物体增加凹凸效果，那么可以使用directional lightmaps。

**2.dual lightlmaps**

如果用户希望在大的游戏场景中表现更多的光影细节，同时多一些实时光影,是动态的物体和静态的物体的光影融合的更加协调一些且不会场景过大而没有足够的性能来完成这些工作，dual lightmaping 是满足这一要求的理想方案。

通过duallightmaps，将渲染区域分为实时和非实时区域，并烘焙远近两种光影贴图，离摄像机远的区域为静态光影区域，不用表现太多的细节，直接用光照图来照亮，而近的区域这需要实时生成的阴影，进行实时光照和bump/spec 映射，同时还融合了near光照贴图中烘焙出来的颜色反射效果，在远近距离的临界区域会做出平滑的差值过渡，这样一来，即丰富了大场景中的光影效果和近距离的光影细节，有不会浪费太多的性能和空间生产大量的实时光影，要使用dual lightmaps 那么需要设置camera属性中的rending path 为DeferredLighting，将需要在近区域实时光源的lightmaping 属性设置为auto，此外，远近区域的划分使用的是shadow distance(实时阴影距离)。

dual lightmaps 最终会生成两种光照图，一个是远处使用的far光照图，一个是在近处使用的near光照图，far光照图和single Lihgtmaps生成的far光照图内容一致，即所有非实时光源的光照信息，在near光照图中保存的只是实时渲染时一些没有的或无法实时计算的信息，比如bakedonly光源的光照信息，auto光源的间接光源以及天空光。

**3.directional  lightmaps**

directional lightmaps 可以是静态物体在利用光光照贴图进行光照的同时混合bump/spec 映射的效果，从而丰富了整个游戏场景的光影细节，让整个场景更加生动逼真，它和dual lightmaps的区别是：directional lightmaps 是作用在整个场景的，不受距离限制，而且在没有实时光源的条件下生成实时bump/spec映射，这是因为光源的信息已经保存到了scale光影图中，directional lightmaps 和single lightmaps一样，会在与动态的物体交互的地方产生双重阴影。


####3、遮挡剔除

遮挡剔除 (Occlusion Culling) 功能可在对象因被其他物体遮挡，当前在相机中无法看到时，禁用对象渲染。该功能不会在三维计算机图形中自动开启，因为在大部分情况下，离相机最远的对象最先渲染，离相机近的对象覆盖先前的物体（该步骤称之为“重复渲染 (overdraw)”）。遮挡剔除 (Occlusion Culling) 与视锥体剔除 (Frustum Culling) 不同。视锥体剔除 (Frustum Culling) 只禁用相机视野外的对象渲染，不禁用视野中被遮挡的任何物体的渲染。注意，使用遮挡剔除 (Occlusion Culling) 功能时，仍将受益于视锥体剔除 (Frustum Culling)。

遮挡剔除过程将使用虚拟相机构建潜在可见对象集的层级视图，应用于整个场景。运行时各相机使用这些数据来确定可见和不可见物体。有了该信息，Unity 将确保仅发送可见对象进行渲染，从而减少绘制调用的次数，提高游戏性能。

遮挡剔除的数据由单元格组成。每个单元格是场景中整个包围区域的细分部分。更具体来说，单元格组成一个二叉树。遮挡剔除 (Occlusion Culling) 使用两棵树，一个用于视图单元格 (View Cells)（静态对象 (Static Objects)），另一个用于目标单元格 (Target Cells)（移动对象 (Moving Objects)）。视图单元格 (View Cells) 映射到定义可见静态对象的索引列表，使静态对象的剔除结果更精确。

创建对象时要切记这一点，因为对象大小需要与单元格大小达到良好平衡。理论上说，单元格不应比对象小太多，同时对象也不应占用太多单元格。有时可以将大对象分成几个小块，改善剔除效果。也可以合并一些小对象，减少绘制调用。只要都在同一个单元格内，遮挡剔除就不会受影响。单元格集合和确定哪些单元格可以在任何其他单元格中可见的可见性信息被称为 PVS（潜在可见集合 (Potentially Visible Set)）。

如需使用遮挡剔除 (Occlusion Culling) 功能，须手动设置一些项。首先，关卡中的几何体必须分成几个大小适中的部分。这也有助于布置关卡中被墙壁、建筑物等大对象相互遮挡的明确定义的小区域。所用原理为单个网格根据遮挡数据开启或关闭。如果有一个对象包含室内所有家具，那么整套家具要么全被剔除，要么全不被剔除。这与为每件家具制作网格一样没有多大意义，以便每件家具都能根据相机视点被单个剔除。

须在检视器 (Inspector) 中将想要成为遮挡的一部分的所有场景对象标记成静态遮挡物 (Occluder Static)。最快的操作方法为选择多个想要加入遮挡计算的对象，将其标记为静态遮挡物 (Occluder Static) 和静态被遮挡物 (Occludee Static)。

应在什么时候使用静态被遮挡物 (Occludee Static)？不会遮挡其他对象的透明物体及也不太可能遮挡的小对象应标为被遮挡物 (Occludees)，而不是遮挡物 (Occluders)。也就是说考虑这些对象被其他对象遮挡，其本身不视为遮挡物，帮助减少计算任务量。

注意：如果默认不创建任何遮挡区域，遮挡剔除将应用到整个场景。

注意：只要相机位于遮挡区域外，遮挡剔除就不会应用。设置遮挡区域 (Occlusion Area) 覆盖相机可能出现的位置非常重要，但会把区域放的太大，烘培时耗费性能。

>创建遮挡区域 (Occlusion Area) 之后，请勾选目标体积 (Is Target Volume) 复选框来遮挡正在移动的对象。

设置好遮挡后，您可以通过启用遮挡剔除 (Occlusion Culling)（位于可视化 (Visualize) 模式下的遮挡剔除预览面板 (Occlusion Culling Preview Panel) 中）并在场景视图中四处移动主相机 (Main Camera) 来测试它。