##使用传输层API

网络传输不稳定，因此需要对数据进行多次编码和校验来确保数据的有效传输。

在实现网络传输时，人们把通信问题划分成了多个小问题，然后为每个小问题设计了一个单独的协议，使得每个协议都比较简单。

国际化标准组织（ISO）和国际电报电话咨询委员会（CCITT）共同制定了开放系统互联的七层参考模型，即把网络传输划分为7个独立的层次。

ISO七层网络模型

|层级|说明|
|:--|:--|
|应用层|应用程序提供的服务|
|表示层|格式化数据，以便为应用程序提供通用接口|
|会话层|在两个节点之间建立端连接|
|传输层|面向连接或无连接的常规数据递送，TCP和UDP协议属于传输层协议|
|网络层|通过寻址来建立两个节点之间的连接，IP协议属于网络层协议|
|数据链路层|将数据分帧，添加校验机制，并处理流控制|
|物理层|原始二进制流的传输|

>其中应用层、表示层和会话层统称为应用层，没有明确的界定，一般由程序开发者实现。

>传输层、网络层、数据链路层和物理层为底层，由操作系统提供。


####应用层（应用层、表示层、会话层）

把用户的数据转化成二进制流传递给传输层。

####传输层

以TCP协议为例：

TCP提供了IP环境下的数据可靠传输，它实现了数据流传送、可靠性校验、流量控制等功能。

传输层的数据转换：数据前添加一个TCP首部。  

    TCP首部|01010110


####网络层

以IP协议为例：

IP协议用于将多个包的交换网络连接起来，它在源地址和目的地址之间传送数据包，它还提供了对数据进行重新组装的功能，以适应不同网络对包大小的不同要求。

网络层的数据转换：IP协议会给数据加上目的地地址（IP地址和端口）等信息，必要时还会拆分数据。

    IP首部|TCP首部|01010110


####数据链路层

传输中若发生差错，为了达成只将有错的有限数据进行重发，数据链路层将二进制流组合成帧，然后以帧为单位进行传送。每个帧除了要传送的数据外，还包括校验码，以使接收方能发现传输中的差错。

>比如奇偶校验码是在原信息的最后添加一位用于奇校验或偶校验的代码。如果原始信息为“10010”，因为1的个数是2，所以会在后面添加一个0，形成“100100”。如果原始信息为“11010”，因为1的个数是3，所以要在后面添加一个1，形成“110101”。对端程序只要检验最后一位，便能够初步判定数据是否正确发送，如果不正确则要求重发。可见数据链路层会拆分数据并添加一些额外数据。

    帧首部|数据  帧首部|数据  帧首部|数据


####物理层

物理层传输就是数据通过物理介质进行传输的过程，物理介质包括电缆、光纤等物质。这些数据通过物理介质传输到目的地，目的地再依照与上述相反的过程进行解析，最后得到用户的数据。

---

####IP与端口

网络上的计算机都是通过IP地址进行识别的，应用程序通过通信端口彼此通信。

#####&emsp;&emsp;IP地址

    例如：
        IP：192.168.1.100

在Windows命令提示符中输入ipconfig，便能够查看本机的IP地址。


#####&emsp;&emsp;端口

“端口“是英文port的意译，是设备与外界通信交流的出口，每台计算机可以分配0到65535共65536个端口。其中0到1023号端口称为众所周知的端口号，它们被分配给一些固定的服务，比如80端口分配给WWW服务，21端口分配给FTP服务。

>我们在浏览器中输入一个网址（网址通过域名系统转换为IP地址）时不必指定端口号，因为在默认情况下WWW服务的端口是80。


#####&emsp;&emsp;C#中的相关类型

C#的System.Net命名空间提供了两个IP和端口相关的类IPAddress和IPEndPoint。

IPAddress ： 指示IP地址，如“127.0.0.1”。
IPEndPoint ： 指示IP地址和端口对的组合，如“127.0.0.1:80”。

|IPAddress的常用属性|说明|
|:--|:--|
|IPAddress.Any|使用机器上一个可用的IP来初始化这个IP地址对象|
|IPAddress.Parse|根据IP地址创建IPAddress对象，如IPAddress.Parse("192.168.0.1")|

|IPEndPoint的常用构造函数|说明|
|:--|:--|
|IPEndPoint(Int64, Int32)|用指定的地址和端口号初始化|
|IPEndPoint(IPAddress, Int32)|用IPAddress指定的地址和端口号初始化|

|IPEndPoint的常用属性|说明|
|:--|:--|
|Address|获取或设置终结点的IP地址|
|Port|获取或设置终结点的端口号|


---

####TCP协议

TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，而与TCP相对应的UDP协议则是无连接的、不可靠的协议（但传输效率比TCP高）。

#####&emsp;&emsp;TCP连接的建立

TCP是面向连接的，无论哪一方在向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP／IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号，并交换TCP窗口大小的信息。

#####&emsp;&emsp;TCP的数据传输

发送一个数据后，发送方并不能确保数据一定会被接收方接收。于是发送方会等待接收方的回应，如果太长时间没有收到回应，发送方会重新发送数据。

#####&emsp;&emsp;TCP连接的终止

客户端和服务器通过三次握手建立了TCP连接以后，待数据传送完毕，便要断开连接。与三次握手相似，TCP通过“四次挥手”来确保双端都断开了连接。

第一次挥手：主机1（可以是客户端也可以是服务器）向主机2发送一个终止信号（FIN），此时，主机1进入FIN_WAIT_1状态，它没有需要发送的数据，只需要等待主机2的回应。

第二次挥手：主机2收到了主机1发送的终止信号（FIN），向主机1回应一个ACK。收到ACK的主机1进入FIN_WAIT_2状态。

第三次挥手：在主机2把所有数据发送完毕后，主机2向主机1发送终止信号（FIN），请求关闭连接。

第四次挥手：主机1收到主机2发送的终止信号（FIN），向主机2回应ACK。然后主机1进入TIME_WAIT状态（等待一段时间，以便处理主机2的重发数据）。主机2收到主机1的回应后，关闭连接。至此，TCP的四次挥手便完成了，主机1和主机2都关闭了连接。

---

####Socket套接字

#####&emsp;&emsp;Socket连接的流程

套接字是支持TCP／IP协议网络通信的基本操作单元，可以将套接字看作不同主机间的进程双向通信的端点，它构成了单个主机内及整个网络间的编程界面。套接字存在于通信域中，通信域是为了处理一般的线程通过套接字通信而引进的一种抽象概念。套接字通常会和同一个域中的套接字交换数据（数据交换也可能会穿越域的界限，但这时一定要执行某种解释程序）。各种进程使用这个相同的域用Internet协议来进行互相之间的通信。

![](/assets/Socket.png)


Socket通信的基本流程具体步骤如下所示：

1）开启一个连接之前，需要先完成Socket和Bind两个步骤。Socket是新建一个套接字，Bind指定套接字的IP和端口（客户端在调用Connect时会由系统分配端口，因此可以省去Bind）。

2）服务端通过Listen开启监听，等待客户端接入。

3）客户端通过Connect连接服务器，服务端通过Accept接收客户端连接。在connect-accept过程中，操作系统将会进行三次握手。

4）客户端和服务端通过Send和Receive发送和接收数据，操作系统将会完成TCP数据的确认、重发等步骤。

5）通过Close关闭连接，操作系统会进行四次挥手。

#####&emsp;&emsp;Socket类

&emsp;&emsp;System.Net.Sockets命名空间的Socket类为网络通信提供了一套丰富的方法和属性。

|Socket类的一些常用方法|说明|
|:--|:--|
|Bind|使Socket与一个本地终结点相关联|
|Listen|将Socket置于侦听状态|
|Accept|为新建连接创建新的Socket|
|Connect|建立与远程主机的连接|
|Send|将数据发送到连接的Socket|
|Receive|接收来自绑定的Socket的数据|
|||

































