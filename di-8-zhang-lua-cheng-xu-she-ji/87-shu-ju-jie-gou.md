##数据结构

&emsp;&emsp;Lua中的table不是一种简单的数据结构，它可以作为其他数据结构的基础。其他语言提供的数据结构，如数组、记录、线性表、队列、集合等，在Lua中都可以通过table来表示。此外，用Lua的table来实现这些结构的效率高。

&emsp;&emsp;在C和Pascal这样的传统语言中，尽管可以使用Lua的table来实现数组和列表，但通常以数组和列表（记录+指针）来实现大多数的数据结构。因为table本身就比数组和列表的功能强大得多。由此许多算法都可以忽略一些细节问题，从而简化它们的实现。例如，在Lua中很少编写搜索算法，这是因为table本身就提供了直接访问任意类型的功能。

&emsp;&emsp;高效地使用table是问题的关键。接下来将演示如何通过table来实现一些传统的数据结构，并且还将给出一些使用这些结构的例子。首先从数组和列表开始，不是因为需要它们来作为其他结构的基础，而是因为大多数程序员都比较熟悉它们了。在前面关于语言的章节中也曾提到过这方面的内容，不过为了完整性起见，本章将更详细地进行讨论。

&emsp;&emsp;

####数组

&emsp;&emsp;使用整数来索引table即可在Lua中实现数组。因此，数组没有一个固定的大小，可以根据需要增长。通常，当初始化一个数组时，也就间接地定义了它的大小。

&emsp;&emsp;例如，在执行了以下代码后，任何对字段范围1～1000之外的访问都会返回一个nil，而不是0：

```lua
    a = {}                -- 新建一个数组
    for i = 1, 1000 do
        a[i] = 0
    end
```

&emsp;&emsp;长度操作符（`#`）依赖于这个事实来计算数组的大小：

```lua
    print(#a)            --> 1000
```

&emsp;&emsp;可以使用0、1或其他任意值来作为数组的起始索引：

```lua
    -- 使用索引值-5～5来创建一个数组
    a = {}
    for i = -5, 5 do
        a[i] = 0
    end
```

>&emsp;&emsp;然而，在Lua中的习惯一般是以1作为数组的起始索引。Lua库和长度操作符都遵循这个约定。如果你的数组不是从1开始的，那就无法使用这些功能了。

&emsp;&emsp;通过table的构造式，可以在一句表达式中创建并初始化数组：

```lua
    squares = {1, 4, 9, 16, 25, 36, 49, 64, 81}
```

&emsp;&emsp;这种构造式可以根据要求变得更长。


&emsp;&emsp;

####矩阵与多维数组

&emsp;&emsp;在Lua中，有两种方式来表示矩阵。第一种是使用一个“数组的数组”，也就是说，一个table中的每个元素是另一个table。例如，使用以下代码来创建N×M的零矩阵：

```lua
    mt = {}                -- 创建矩阵
    for i = 1, N do
        mt[i] = {}             -- 创建一个新行
        for j = 1, M do
            mt[i][j] = 0
        end
    end
```

&emsp;&emsp;由于在Lua中table是一种对象，因此在创建矩阵时，必须显式地创建每一行。从一方面看，这的确比在C和Pascal中直接声明一个多维数组烦琐；但从另一方面看，它也给予了更多的灵活性。例如，创建一个三角形矩阵，只需将前例中的循环`for j = 1, M do ... end`改为`for j = 1, i do ...end`。这种修改同时可以使三角形矩阵只使用原先一半的内存。

&emsp;&emsp;在Lua中表示矩阵的第二种方式是将两个索引合并为一个索引。如果两个索引是整数，可以将第一个索引乘以一个适当的常量，并加上第二个索引。以下代码就使用这种方法来创建N×M：

```lua
    mt = {}        -- 创建矩阵
    for i = 1, N do
        for j = 1, M do
            mt[(i-1)*M + j] = 0
        end
    end
```

&emsp;&emsp;如果索引是字符串，那么可以把索引拼接起来，中间使用一个字符来分隔。例如，使用字符串s和t来索引一个矩阵，可以通过代码`m[s..":"..t]`。其中，s和t都不能包含冒号，否则像（"a:", "b"）或（"a", ":b"）这样的索引会使最终索引变成“a::b”。如果无法保证这点的话，可以使用例如'\0'这样的控制字符来分隔两个索引。

&emsp;&emsp;通常应用程序会用到一种特殊的矩阵，称为“稀疏矩阵”，这种矩阵中的大多数元素为0或nil。例如，可以通过稀疏矩阵来表示一个图（graph）。当矩阵的m，n位置上有一个值x，即表示图中的结点m和n是相连的，其权重（cost）为x；若图中这些节点不相连的话，则矩阵m，n位置上的值为nil。若要表示一个具有1万个节点的图，其中每个结点大约会与其他5个结点相连，那么就需要一个能包含1亿个元素的矩阵，但是其中大约只有5万个元素不为nil。许多数据结构的书籍都会讨论到这个大小问题，如何才能实现这种稀疏矩阵而不浪费400MB内存。当在Lua中编程时，则无须用到这些技术。因为，数组是以table来表示的，它们本身就是稀疏的。在第一种表示（table的table）中，需要1万个table，每个table包含5个元素，总共5万个条目。在第二种表示中，需要一个table，其中包含5万个条目。无论哪种表示方式，都只需要为非nil的元素付出空间。

&emsp;&emsp;虽然对稀疏矩阵使用长度操作符不是一种语法错误。但也不能进行该操作，因为在有效条目之间存在“空洞（nil值）”。在大多数对稀疏矩阵的操作中，由于存在许多空条目，遍历矩阵是非常低效的。所以，一般使用pairs且只遍历那些非nil的元素。

&emsp;&emsp;例如，要将矩阵的一行与一个常量相乘，可以使用以下代码：

```lua
    function mult(a, rowindex, k)
        local row = a[rowindex]
        for i, v in pairs(row) do
            row[i] = v * k
        end
    end
```

&emsp;&emsp;注意，table中的key是无序的，所以使用pairs的迭代并不保证会按递增次序来访问元素。对于一些任务而言（像上面这个例子），这没有问题；但对于另一些任务而言，或许就需要采用另外的方法了，比如链表。


&emsp;&emsp;

####链表

&emsp;&emsp;由于table是动态的实体，所以在Lua中实现链表是很方便的。每个结点以一个table来表示，一个“链接”只是结点table中的一个字段，该字段包含了对其他table的引用。

&emsp;&emsp;例如，要实现一个基础的列表，其中每个结点具有两个字段：next和value，先创建一个用作列表头结点的变量：

