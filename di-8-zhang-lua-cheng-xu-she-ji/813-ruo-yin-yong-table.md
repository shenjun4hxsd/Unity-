##弱引用table

&emsp;&emsp;Lua采用了自动内存管理。一个程序只需创建对象，而无须删除对象。通过使用垃圾收集机制，Lua会自动地删除那些已成为垃圾的对象。这减轻了程序员在内存管理方面的负担，更重要的是将程序员从许多内存相关的bug（例如无效指针、内存泄漏）中解放出来。

&emsp;&emsp;Lua的垃圾收集器与一些其他的收集器有所不同，它没有环形引用的问题。当用到环形数据结构时，无须作出任何特殊的处理，它们也可以像其他数据一样被正常回收。不过，有时即使是再聪明的收集器也需要帮助。垃圾收集器无法解决所有内存管理的问题。

&emsp;&emsp;垃圾收集器只能回收那些它认为是垃圾的东西，它不会回收那些用户认为是垃圾的东西。一个典型的例子就是栈，栈通常由一个数组和一个表示顶部的索引来实现。这个数组的有效部分总是向顶部扩展的，但Lua却不知道。如果弹出一个元素时只是简单地递减顶部索引，那么这个仍留在数组中的对象对于Lua来说就不是垃圾。同理，对于那些存储在全局变量中的对象，即使程序不会再用到它们，但对于Lua来说就不是垃圾。在这两种情况中，都需要由用户来将这些对象变量赋值为`nil`。这样才能使它们得以释放。

&emsp;&emsp;不过，简单地清楚引用可能还不够。有些情况需要程序和收集器之间进行更多的协作。例如，如果要将一些对象放在一个数组中，这看似简单，好像只需把每个对象插入数组即可。但是，当一个对象处于数组中时，它就无法被回收。这是因为即使当前没有其他地方在使用它，但数组仍引用着它。除非用户告诉Lua这项引用不应该阻碍此对象的回收，否则，Lua是无从得知这个事实的。