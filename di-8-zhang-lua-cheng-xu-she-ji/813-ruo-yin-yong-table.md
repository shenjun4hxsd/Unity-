##弱引用table

&emsp;&emsp;Lua采用了自动内存管理。一个程序只需创建对象，而无须删除对象。通过使用垃圾收集机制，Lua会自动地删除那些已成为垃圾的对象。这减轻了程序员在内存管理方面的负担，更重要的是将程序员从许多内存相关的bug（例如无效指针、内存泄漏）中解放出来。

&emsp;&emsp;Lua的垃圾收集器与一些其他的收集器有所不同，它没有环形引用的问题。当用到环形数据结构时，无须作出任何特殊的处理，它们也可以像其他数据一样被正常回收。不过，有时即使是再聪明的收集器也需要帮助。垃圾收集器无法解决所有内存管理的问题。

&emsp;&emsp;垃圾收集器只能回收那些它认为是垃圾的东西，它不会回收那些用户认为是垃圾的东西。一个典型的例子就是栈，栈通常由一个数组和一个表示顶部的索引来实现。这个数组的有效部分总是向顶部扩展的，但Lua却不知道。如果弹出一个元素时只是简单地递减顶部索引，那么这个仍留在数组中的对象对于Lua来说就不是垃圾。同理，对于那些存储在全局变量中的对象，即使程序不会再用到它们，但对于Lua来说就不是垃圾。在这两种情况中，都需要由用户来将这些对象变量赋值为`nil`。这样才能使它们得以释放。

&emsp;&emsp;不过，简单地清楚引用可能还不够。有些情况需要程序和收集器之间进行更多的协作。例如，如果要将一些对象放在一个数组中，这看似简单，好像只需把每个对象插入数组即可。但是，当一个对象处于数组中时，它就无法被回收。这是因为即使当前没有其他地方在使用它，但数组仍引用着它。除非用户告诉Lua这项引用不应该阻碍此对象的回收，否则，Lua是无从得知这个事实的。

&emsp;&emsp;弱引用`table`（`weak table`）就是这样一种机制，用户能用它来告诉Lua一个引用不应该阻碍一个对象的回收。所谓“弱引用（`weak reference`）”就是一种会被垃圾收集器忽视的对象引用。如果一个对象的所有引用都是弱引用，那么Lua就可以回收这个对象了，并且还可以以某种形式来删除这些弱引用本身。Lua用“`弱引用table`”来实现“弱引用”，一个弱引用`table`就是一个具有弱引用条目的`table`。如果一个对象只被一个弱引用`table`所持有，那么最终Lua是会回收这个对象的。

&emsp;&emsp;`table`中有`key`和`value`，这两者都可以包含任意类型的对象。通常，垃圾收集器不会回收一个可访问`table`中作为`key`或`value`的对象。也就是说，这些`key`和`value`都是强引用（`strong reference`），它们会阻止对其所引用对象的回收。在一个弱引用`table`中，`key`和`value`是可以回收的。有3种弱引用`table`：具有弱引用`key`的`table`、具有弱引用`value`的`table`、同时具有两种弱引用`table`。不论是哪种类型的弱引用`table`，只要有一个`key`或`value`被回收了，那么它们所在的整个条目都会从`table`中删除。


&emsp;&emsp;一个table的弱引用类型是通过其元表中的`__mode`字段来决定的。这个字段的值应为一个字符串，如果这个字符串中包含字母‘`k`’，那么这个table的key是弱引用的；如果这个字符串中包含字母‘`v`’，那么这个`table`的`value`是弱引用的。下面这个示例虽然是人为制造的，但演示了弱引用`table`的一些基本行为：

```lua
    a = {}
    b = {__mode = 'k'}
    setmetatable(a, b)    -- 现在'a'的key就是弱引用
    key = {}              -- 创建第一个key
    a[key] = 1
    key = {}              -- 创建第二个key
    a[key] = 2
    collectgarbage()      -- 强制进行一次垃圾收集
    for k, v in pairs(a) do print(v) end
    --> 2
```

&emsp;&emsp;在本例中，第二句赋值`key = {}`会覆盖第一个`key`。当收集器运行时，由于没有其他地方在引用第一个`key`，因此第一个`key`就被回收了，并且`table`中的相应条目也被删除了。至于第二个key，变量key仍引用着它，因此它没有被回收。

